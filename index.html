<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atividades - Processamento digital de imagens</title>
</head>
<style>
    h1{ color:darkred;}
    h2{ color:darkred}
    h3{ color:darkred}
    h4{ color:darkred}




    
</style>
    <h1 style = "font-size: 350%"><font face="montserrat">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atividades</font></h1>
    <font face="Montserrat">&nbsp;&nbsp;&nbsp;Discente : Flávio henrique Lopes Barbosa - flavio.lopes.039@ufrn.br </font>
    <p> </p>
    <h2 style = "font-size: 250%">  <font face="montserrat"> &nbsp;Processamento Digital de Imagens</font> </h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Essa página se destina a exibição de atividades propostas na disciplina de Processamento Digital de Imagens. A linguagem escolhida para implemnetação foi C++. Os códigos foram feitos no editor de texto padrão do Ubuntu, sendo compilados e executados via terminal com as flags específicas fornecidas no arquivo Make.</p>

    
    <h3>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atividade 1</h3>
    <p> </p>
    <b>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Manipulação de Pixels</b>
    <p> </p>
    <div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tal atividade refere-se a inversão dos tons de cinza, obtendo assim um negativo de uma região escolhida a partir da interação com  usuário, o qual fornecerá as coordenadas que compreendem o espaço que será aplicado o negativo.</p>
    <p>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O código utilizado na prática se encontra abaixo:</p>
    <p> </p>
    <pre><code class="c++" contentEditable="true">

            #include < iostream >
            #include < opencv4/opencv2/opencv.hpp >
            
                using namespace cv;
                using namespace std;
                
                int main(int, char**){
                Mat image;
                Vec3b val;
                
                image= imread("capa.png",CV_IMREAD_GRAYSCALE);
                if(!image.data)
                cout << "nao abriu capa.png" << endl;
                
                namedWindow("janela",CV_WINDOW_AUTOSIZE);
                
                    int x1, y1, x2, y2;
                
                    cout << "O tamanho da imagem é: " << image.size().height << "/"<< image.size().width << " Escreva pontos dentro desse limite."<< endl;
                
                    do{
                        cout << "digite o primeiro ponto (x):" << endl;
                        cin >> x1;
                        if(x1 >= image.rows || x1 < 0)
                            cout << "Número Inválido :). Insira Novamente." << endl;
                    }
                    while(x1 >=image.rows);
                
                    do{
                        cout << "digite o primeiro ponto (y):" << endl;
                        cin >> y1;
                        if(y1 >= image.cols || y1 < 0)
                            cout << "Número Inválido :). Insira Novamente." << endl;
                    }
                    while(y1 >=image.cols);
                
                    do{
                        cout << "digite o segundo ponto (x):" << endl;
                        cin >> x2;
                        if(x2 >= image.rows || x2 < 0)
                            cout << "Número Inválido :). Insira Novamente." << endl;
                    }
                    while(x2 >=image.rows);
                
                    do{
                        cout << "digite o segundo ponto (y):" << endl;
                        cin >> y2;
                        if(y2 >= image.cols || y2 < 0)
                            cout << "Número Inválido :). Insira Novamente." << endl;
                    }
                    while(y2 >=image.cols);
                        for(int i=x1; i< x2; i++) {
                            for ( int j=y1; j< y2; j++){
                            image.at < uchar > (i,j)=255-image.at < uchar > (i,j); 
                        }
                
                }
                
                imwrite("apply.png",image);
                imshow("janela", image);
                waitKey();
                return 0;
                }
        </code></pre>
    
    </div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A imagem utilizada na prática foi uma gravura do encarte de um álbum do fim dos anos 90, o "Mellow Collie and infinite sadness", da banda The Smashing Pumpkins. Apresentado abaixo:</p>
    <p> </p>
    <center>
        <div>
    <img src="capa.png" alt="01">
    <div>
    </center>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A imagem já era em tons cinza mas mesmo assim foi aplicado o carregamento do arquivo na escala de cinza</p>

    <code> &nbsp;&nbsp;&nbsp;image= imread("capa.png",CV_IMREAD_GRAYSCALE);</code>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O programa permite ao usuário escolher dois pontos, P1(x1,y1) e P2(x2,y2) que envolvem uma região que será varrida pelo for aninhado, de forma a "negativar" seus pixels.</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Para a imagem Obitida foram utilizadas as seguintes coordenadas:</p>
    <center>
        <div>
    <img src="dim1.png" alt="02">
    <div>
    </center>
    <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Obtendo como resultado a imagem a seguir com os pixels invertidos na região passada pelo usuário.</p>
    <center>
        <div>
    <img src="apply.png" alt="03">
    <div>
    </center>
    <h3 style = "font-size: 200%"></h3style>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atividades da 2ª Unidade:</h3>
    <b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filtragem no Domínio da Frequência</b>
        <p> </p>
    <b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filtro Homomórfico</b>
    <p> </p>
    <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Nesta atividade utilizaremos um filtro baseado na Transformada de Fourrier, oqual explora a manipulação de propriedades das imagens a partir do domínio da frequência, que tem como objetivo a remoção de ruídos e distorções , geralmente de natureza periódica.</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Algumas funções do Opencv no código usado como referência estavam desatualizadas para versão utilizada ( Opencv 4.2.0 )  de forma a ficarem indefinidas na compilação, tais como  'CV_MINMAX', modificada para 'cv :: NORM_MINMAX' e 'CV_BGR2GRAY', modificada para 'cv :: COLOR_BGR2GRAY'.</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A seguir o código utilizado para a implementação do filtro :</p> 
    <p> </p>
    <pre><code class="c++" contentEditable="true">
            #include <iostream>
            #include <opencv2/opencv.hpp>
            #include <math.h>
            #include <vector>
            
            using namespace cv;
            using namespace std;
            
            int height;
            
            int dft_M, dft_N;
            
            float MAX = 100.0;
            float gl = 0;
            float max_gl = 100;
            int gl_slider = 0;
            
            int d0_slider = 0;
            float max_d0 = 256;
            float d0 = 0;
            
            float gh = 0;
            float max_gh = 100;
            int gh_slider = 0;
            
            float c = 0;
            float max_c = 100;
            int c_slider = 0;
            
            
            Mat image, imageDft, padded;
            
            char TrackbarName[50];
            
            // troca os quadrantes da imagem da DFT
            void deslocaDFT(Mat& image )
            {
                Mat aux, A, B, C, D;
            
                // se for impar recorta para nao ter imagens desiguais
                image = image(Rect(0, 0, image.cols & -2, image.rows & -2));
                int cx = image.cols/2;
                int cy = image.rows/2;
            
                // reorganiza os quadrantes
                A = image(Rect(0, 0, cx, cy));
                B = image(Rect(cx, 0, cx, cy));
                C = image(Rect(0, cy, cx, cy));
                D = image(Rect(cx, cy, cx, cy));
            
                // A <-> D
                A.copyTo(aux);  D.copyTo(A);  aux.copyTo(D);
            
                // C <-> B
                C.copyTo(aux);  B.copyTo(C);  aux.copyTo(B);
            }
            
            void calcFiltroHomomorfico()
            {
                Mat filter = Mat(padded.size(), CV_32FC2, Scalar(0));
                Mat aux = Mat(dft_M, dft_N, CV_32F);
            
                for (int i = 0; i < dft_M; i++)
                {
                    for (int j = 0; j < dft_N; j++)
                    {
                        float d2 = pow(i - dft_M/2.0, 2) + pow(j - dft_N/2.0, 2);
                        float exp = -c * (d2/pow(d0, 2));
                        float valor = (gh - gl)*(1 - expf(exp) ) + gl;
                        aux.at<float> (i,j) = valor;
                    }
                }
            
                Mat comps[] = {aux, aux};
                merge(comps, 2, filter);
            
                Mat dftClone = imageDft.clone();
            
                mulSpectrums(dftClone,filter,dftClone,0);
            
                deslocaDFT(dftClone);
            
                idft(dftClone, dftClone);
            
                vector<Mat> planos;
            
                split (dftClone, planos);
            
                normalize(planos[0], planos[0], 0, 1, cv::NORM_MINMAX);
            
                char bufferd0[20], bufferyh[20], bufferyl[20];
                sprintf(bufferd0, "D0: %f", d0);
                sprintf(bufferyh, "GH: %f", gh);
                sprintf(bufferyl, "GL: %f", gl);
                sprintf(bufferyl, "c: %f", c);
                putText(planos[0], bufferd0,cv::Point(0,10), cv::FONT_HERSHEY_SIMPLEX, 0.35, cv::Scalar(255),1,8,false);
                putText(planos[0], bufferyh,cv::Point(0,20), cv::FONT_HERSHEY_SIMPLEX, 0.35, cv::Scalar(255),1,8,false);
                putText(planos[0], bufferyl,cv::Point(0,30), cv::FONT_HERSHEY_SIMPLEX, 0.35, cv::Scalar(255),1,8,false);
                putText(planos[0], bufferyl,cv::Point(0,40), cv::FONT_HERSHEY_SIMPLEX, 0.35, cv::Scalar(255),1,8,false);
                imshow("Filtro Homomorfico", planos[0]);
            
                imshow("Original", image);
                imwrite("ResultadoHomomorfico.png", planos[0]);
            }
            
            void on_trackbar_gl(int, void*)
            {
                gl = (float) gl_slider;
                gl = max_gl*gl/MAX;
                calcFiltroHomomorfico();
            }
            
             // Declaração de parâmetros ajustáveis
            void on_trackbar_d0(int, void *)
            {
                d0 = d0_slider*max_d0/MAX;
                calcFiltroHomomorfico();
            }
            
            void on_trackbar_gh(int, void*)
            {
                gh = gh_slider*max_gh/MAX;
                calcFiltroHomomorfico();
            }
            void on_trackbar_c(int, void*)
            {
              c = c_slider*max_c/MAX;
              calcFiltroHomomorfico();
            }
            
            int main(int argvc, char** argv)
            {
                //Imagem que deseja Filtrar
                image = imread("boris1.png");
                cvtColor(image, image, cv::COLOR_BGR2GRAY);
            
                height = image.size().height;
            
                // identifica os tamanhos otimos para o calculo do FFT
                dft_M = getOptimalDFTSize(image.rows);
                dft_N = getOptimalDFTSize(image.cols);
            
                // realiza o padding da imagem
                Mat_<float> zeros;
                copyMakeBorder(image, padded, 0,
                               dft_M - image.rows, 0,
                               dft_N - image.cols,
                               BORDER_CONSTANT, Scalar::all(0));
            
                // parte imaginaria da matriz complexa (preenchida com zeros)
                zeros = Mat_<float>::zeros(padded.size());
            
                // prepara a matriz complexa para ser preenchida
                imageDft = Mat(padded.size(), CV_32FC2, Scalar(0));
            
                copyMakeBorder(image, padded, 0,
                               dft_M - image.rows, 0,
                               dft_N - image.cols,
                               BORDER_CONSTANT, Scalar::all(0));
            
                Mat_<float> realInput = Mat_<float>(padded);
            
                vector<Mat> planos;
                planos.push_back(realInput);
                planos.push_back(zeros);
            
                merge(planos, imageDft);
            
                dft(imageDft, imageDft);
                deslocaDFT(imageDft);
            
                namedWindow("Filtro Homomorfico", 1);
            
                sprintf( TrackbarName, "gH");
                createTrackbar( TrackbarName, "Filtro Homomorfico",
                                &gh_slider,
                                MAX,
                                on_trackbar_gh);
            
                sprintf( TrackbarName, "gL");
                createTrackbar( TrackbarName, "Filtro Homomorfico",
                                &gl_slider,
                                MAX,
                                on_trackbar_gl);
            
                sprintf( TrackbarName, "D0");
                createTrackbar( TrackbarName, "Filtro Homomorfico",
                                &d0_slider,
                                MAX,
                                on_trackbar_d0 );
                sprintf( TrackbarName, "c");
                createTrackbar( TrackbarName, "Filtro Homomorfico",
                                &c_slider,
                                MAX,
                                on_trackbar_c);
            
                calcFiltroHomomorfico();
                waitKey(0);
            
            
                return 0;
            }

        </code></pre>
        </div> 
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A imagem utilizada na prática foi uma foto de uma câmera de celular, redimensionada e convertida do formato 'jpeg' para 'png' , posteriormente convertida para a escala de cinza e submetida ao filtro homomórfico (resultado), no qual a aplicação permitiu os ajustes dos parâmetros. Veja as figuras na respectiva sequência descrita, abaixo:</p>
        <center>
            <div>
        <img src="boris1.png" alt="04">
        <div>
        </center>
        <p> </p>
        <center>
            <div>
        <img src="boriso.png" alt="05">
        <div>
        </center>
        <p> </p>
        <center>
            <div>
        <img src="borisfh.png" alt="06">
        <div>
        </center>
        <p> </p>
        <p> </p>
        <b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Canny e a Arte do Pontilhismo</b>
        <p> </p>
        <p> </p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O objetivo desta atividade é realizar um programa que una o pontilhismo, uma técnica de pintura que surgiu no século XIX, com o Algoritmo de detecção de bordas Canny. Assim, obtêm-se uma imagem em pontilhismo criada computacionalmente com opção de realizar variações de raio de cada ponto.Para prática foi utilizada a mesma imagem da atividade anterior.</p> 
        <p></p>
        <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Segue o código utilizado :</p>
        <p></p>
        <p> </p>
        <pre><code class="c++" contentEditable="true">
            #include <iostream>
                #include <opencv2/opencv.hpp>
                #include <fstream>
                #include <iomanip>
                #include <vector>
                #include <algorithm>
                #include <numeric>
                #include <ctime>
                #include <cstdlib>
                
                using namespace std;
                using namespace cv;
                // O step define o passo usado para varrer a imagem de referência
                int step_slider = 5;
                int step_slider_max = 20;
                int jitter_slider = 3;
                int jitter_slider_max = 10;
                int raio_slider = 3;
                int raio_slider_max = 10;
                
                int top_slider = 70;
                int top_slider_max = 200;
                
                char TrackbarName[50];
                
                Mat imagem, borda, pontos;
                
                //arrays de índices que servirão para identificar elementos da imagem de referência
                vector<int> yrange;
                vector<int> xrange;
                
                int width, height, r,g,b;
                int x, y;
                
                void on_trackbar_canny(int, void*)
                {
                  Canny(imagem, borda, top_slider, 3*top_slider);
                
                //É feito o preenchimento de xrange e yrange com valores sequenciais iniciando em 0.
                //Em seguida, esses valores recebem um ganho igual a step e um deslocamento step/2.
                
                  xrange.resize(height/step_slider);
                  yrange.resize(width/step_slider);
                
                  iota(xrange.begin(), xrange.end(), 0);
                  iota(yrange.begin(), yrange.end(), 0);
                
                  for(uint i=0; i<xrange.size(); i++)
                  {
                    xrange[i]= xrange[i]*step_slider+step_slider/2;
                  }
                
                  for(uint i=0; i<yrange.size(); i++)
                  {
                    yrange[i]= yrange[i]*step_slider+step_slider/2;
                  }
                
                  pontos = Mat(height, width, CV_8UC3, CV_RGB(255,255,255));
                
                  //Embaralhamento aleatoriamente
                  random_shuffle(xrange.begin(), xrange.end());
                
                  // i e j assumem a cada passada no loop, os valores dos arrays xrange e yrange de forma consecutiva.
                
                  for(auto i : xrange)
                  {
                    random_shuffle(yrange.begin(), yrange.end());
                    for(auto j : yrange)
                    {
                      if(jitter_slider) x = i+rand()%(2*jitter_slider)-jitter_slider+1;
                      else x = i;
                      if(jitter_slider) y = j+rand()%(2*jitter_slider)-jitter_slider+1;
                      else y = j;
                      b = imagem.at<Vec3b>(x,y)[0];
                      g = imagem.at<Vec3b>(x,y)[1];
                      r = imagem.at<Vec3b>(x,y)[2];
                
                    //É traçado um circulo de raio especificado em um ponto determinado pelo usuario
                      circle(pontos,cv::Point(y,x),raio_slider,CV_RGB(r,g,b),-1,cv::LINE_AA);
                    }
                  }
                
                  for(int i = 0;i<height;i++)
                  {
                    for(int j = 0;j<width;j++)
                    {
                      int borda_radius = borda.at<uchar>(i,j)*(top_slider/40 + 1)/255;
                      b = imagem.at<Vec3b>(i,j)[0];
                      g = imagem.at<Vec3b>(i,j)[1];
                      r = imagem.at<Vec3b>(i,j)[2];
                      circle(pontos,cv::Point(j,i),borda_radius,CV_RGB(r,g,b),-1,cv::LINE_AA);
                    }
                  }
                  imshow("cannypoints",pontos);
                }
                
                int main(int argc, char** argv)
                {
                
                  imagem= imread(argv[1],IMREAD_COLOR);
                
                  if(!imagem.data)
                  {
                    cout << "nao abriu" << argv[1] << endl;
                    cout << argv[0] << " imagem.jpg";
                    exit(0);
                  }
                
                  namedWindow("cannypoints",WINDOW_NORMAL);
                  imshow("cannypoints",imagem);
                
                  srand(time(0));
                
                  width=imagem.size().width;
                  height=imagem.size().height;
                
                  sprintf( TrackbarName, "Threshold inferior x %d", top_slider_max );
                  createTrackbar( TrackbarName, "cannypoints", &top_slider, top_slider_max, on_trackbar_canny );
                
                  sprintf( TrackbarName, "step x %d",  step_slider_max );
                  createTrackbar( TrackbarName, "cannypoints", &step_slider, step_slider_max, on_trackbar_canny );
                
                  sprintf( TrackbarName, "Jitter x %d", jitter_slider_max );
                  createTrackbar( TrackbarName, "cannypoints", &jitter_slider, jitter_slider_max, on_trackbar_canny );
                
                  sprintf( TrackbarName, "Raio x %d", top_slider_max );
                  createTrackbar( TrackbarName, "cannypoints", &raio_slider, raio_slider_max, on_trackbar_canny );
                
                  waitKey();
                  return 0;
                }


                  </code></pre>
                   </div>  
                    <p></p>
                   <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abaixo o resultado, que poderia ser ajustado de acordo com os parâmetros, pelo usuário:</p>
                   <p></p>

                   <p> </p>
                   <center>
                       <div>
                   <img src="borinho.png" alt="07">
                   <div>
                   </center>
                   <p> </p>


        




</body>
</html>
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atividades - Processamento digital de imagens</title>
</head>
<style>
    h1{ color:darkred;}
    h2{ color:darkred}
    h3{ color:darkred}
    h4{ color:darkred}




    
</style>
    <h1 style = "font-size: 350%"><font face="montserrat">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atividades</font></h1>
    <font face="Montserrat">&nbsp;&nbsp;&nbsp;Discente : Flávio henrique Lopes Barbosa - flavio.lopes.039@ufrn.br </font>
    <p> </p>
    <h2 style = "font-size: 250%">  <font face="montserrat"> &nbsp;Processamento Digital de Imagens</font> </h2>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Essa página se destina a exibição de atividades propostas na disciplina de Processamento Digital de Imagens. A linguagem escolhida para implemnetação foi C++. Os códigos foram feitos no editor de texto padrão do Ubuntu, sendo compilados e executados via terminal com as flags específicas fornecidas no arquivo Make.</p>

    
    <h3>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atividade 1</h3>
    <p> </p>
    <b>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Manipulação de Pixels</b>
    <p> </p>
    <div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tal atividade refere-se a inversão dos tons de cinza, obtendo assim um negativo de uma região escolhida a partir da interação com  usuário, o qual fornecerá as coordenadas que compreendem o espaço que será aplicado o negativo.</p>
    <p>     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O código utilizado na prática se encontra abaixo:</p>
    <p> </p>
    <pre><code class="c++" contentEditable="true">

            #include < iostream >
            #include < opencv4/opencv2/opencv.hpp >
            
                using namespace cv;
                using namespace std;
                
                int main(int, char**){
                Mat image;
                Vec3b val;
                
                image= imread("capa.png",CV_IMREAD_GRAYSCALE);
                if(!image.data)
                cout << "nao abriu capa.png" << endl;
                
                namedWindow("janela",CV_WINDOW_AUTOSIZE);
                
                    int x1, y1, x2, y2;
                
                    cout << "O tamanho da imagem é: " << image.size().height << "/"<< image.size().width << " Escreva pontos dentro desse limite."<< endl;
                
                    do{
                        cout << "digite o primeiro ponto (x):" << endl;
                        cin >> x1;
                        if(x1 >= image.rows || x1 < 0)
                            cout << "Número Inválido :). Insira Novamente." << endl;
                    }
                    while(x1 >=image.rows);
                
                    do{
                        cout << "digite o primeiro ponto (y):" << endl;
                        cin >> y1;
                        if(y1 >= image.cols || y1 < 0)
                            cout << "Número Inválido :). Insira Novamente." << endl;
                    }
                    while(y1 >=image.cols);
                
                    do{
                        cout << "digite o segundo ponto (x):" << endl;
                        cin >> x2;
                        if(x2 >= image.rows || x2 < 0)
                            cout << "Número Inválido :). Insira Novamente." << endl;
                    }
                    while(x2 >=image.rows);
                
                    do{
                        cout << "digite o segundo ponto (y):" << endl;
                        cin >> y2;
                        if(y2 >= image.cols || y2 < 0)
                            cout << "Número Inválido :). Insira Novamente." << endl;
                    }
                    while(y2 >=image.cols);
                        for(int i=x1; i< x2; i++) {
                            for ( int j=y1; j< y2; j++){
                            image.at < uchar > (i,j)=255-image.at < uchar > (i,j); 
                        }
                
                }
                
                imwrite("apply.png",image);
                imshow("janela", image);
                waitKey();
                return 0;
                }
        </code></pre>
    
    </div>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A imagem utilizada na prática foi uma gravura do encarte de um álbum do fim dos anos 90, o "Mellow Collie and infinite sadness", da banda The Smashing Pumpkins. Apresentado abaixo:</p>
    <p> </p>
    <center>
        <div>
    <img src="capa.png" alt="01">
    <div>
    </center>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A imagem já era em tons cinza mas mesmo assim foi aplicado o carregamento do arquivo na escala de cinza</p>

    <code> &nbsp;&nbsp;&nbsp;image= imread("capa.png",CV_IMREAD_GRAYSCALE);</code>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Oprograma permite ao usuário escolher dois pontos, P1(x1,y1) e P2(x2,y2) que envolvem uma região que será varrida pelo for aninhado, de forma a "negativar" seus pixels.</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Para a imagem Obitida foram utilizadas as seguintes coordenadas:</p>
    <center>
        <div>
    <img src="dim1.png" alt="02">
    <div>
    </center>
    <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Obtendo como resultado a imagem a seguir com os pixels invertidos na região passada pelo usuário.</p>
    <center>
        <div>
    <img src="apply.png" alt="03">
    <div>
    </center>
    <h3 style = "font-size: 200%"></h3style>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atividades da 2ª Unidade:</h3>
    <b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filtragem no Domínio da Frequência</b>
        <p> </p>
    <b> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Filtro Homomórfico</b>
    <p> </p>
    <p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Nesta atividade utilizaremos um filtro baseado na Transformada de Fourrier, oqual explora a manipulação de propriedades das imagens a partir do domínio da frequência, que tem como objetivo a remoção de ruídos e distorções , geralmente de natureza periódica.</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Algumas funções do Opencv no código usado como referência estavam desatualizadas para versão utilizada ( Opencv 4.2.0 )  de forma a ficarem indefinidas na compilação, tais como  'CV_MINMAX', modificada para 'cv :: NORM_MINMAX' e 'CV_BGR2GRAY', modificada para 'cv :: COLOR_BGR2GRAY'.</p>
    <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

</body>
</html>